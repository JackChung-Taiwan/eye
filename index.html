<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Performance Eye Tracking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #111;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      let handpose;
      let video;
      let predictions = [];
      
      // --- 優化設定 1: 提高跟隨速度 ---
      let lerpX = 0;
      let lerpY = 0;
      // 從 0.1 改為 0.4，數值越大反應越快 (最大 1.0)
      let lerpSpeed = 0.4; 

      let particles = [];
      // --- 優化設定 2: 限制粒子最大數量 ---
      const MAX_PARTICLES = 40; 

      // 自動眨眼變數
      let isBlinking = false;
      let nextBlinkTime = 0;
      let blinkDuration = 150; // 眨眼速度也調快一點
      let blinkEndTime = 0;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        // 不限制幀率，讓它盡量跑滿 60fps
        // frameRate(60); 

        colorMode(HSB, 360, 100, 100, 100);
        angleMode(RADIANS); 
        noStroke();

        lerpX = width / 2;
        lerpY = height / 2;
        nextBlinkTime = millis() + 2000;

        // --- 優化設定 3: 降低運算解析度 ---
        video = createCapture(VIDEO);
        // 設定為極低解析度，這對 Handpose 偵測來說已經足夠，但速度會快非常多
        video.size(160, 120); 
        video.hide();

        console.log("載入極速模式模型中...");
        // 載入模型
        handpose = ml5.handpose(video, modelReady);
        
        // 綁定預測事件
        handpose.on("predict", (results) => {
          predictions = results;
        });
      }

      function modelReady() {
        console.log("模型載入完成！現在應該會很順暢。");
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }

      function draw() {
        // 使用不透明度較高的背景覆蓋，減少殘影計算負擔
        background(240, 80, 10, 40); 

        let targetX, targetY;
        let handDetected = false;
        let currentTime = millis();

        // --- 1. 偵測與座標計算 ---
        if (predictions.length > 0) {
          handDetected = true;
          isBlinking = false; 
          nextBlinkTime = currentTime + random(2000, 4000);

          let indexFingerTip = predictions[0].annotations.indexFinger[3];
          
          // 映射座標 (使用 video 的小尺寸進行映射)
          targetX = map(indexFingerTip[0], 0, video.width, width, 0);
          targetY = map(indexFingerTip[1], 0, video.height, 0, height);

          // 產生粒子 (每次只產生 1 個，減少負擔)
          particles.push(new Particle(targetX, targetY));

        } else {
          handDetected = false;
          targetX = width / 2;
          targetY = height / 2;

          // 自動眨眼邏輯
          if (!isBlinking && currentTime > nextBlinkTime) {
            isBlinking = true;
            blinkEndTime = currentTime + blinkDuration;
          } else if (isBlinking && currentTime > blinkEndTime) {
            isBlinking = false;
            nextBlinkTime = currentTime + random(2000, 5000);
          }
        }

        // --- 2. 粒子系統優化管理 ---
        // 限制粒子總數，如果超過就把最舊的刪掉
        if (particles.length > MAX_PARTICLES) {
            particles.splice(0, particles.length - MAX_PARTICLES);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update();
          particles[i].show();
          if (particles[i].isFinished()) {
            particles.splice(i, 1);
          }
        }

        // --- 3. 快速平滑移動 ---
        lerpX = lerp(lerpX, targetX, lerpSpeed);
        lerpY = lerp(lerpY, targetY, lerpSpeed);

        // 繪製眼睛
        let eyeDiameter = min(width, height) * 0.3;
        let eyeSpacing = eyeDiameter * 1.1;
        let centerY = height / 2;
        
        drawEye(width / 2 - eyeSpacing / 2, centerY, eyeDiameter, lerpX, lerpY, isBlinking);
        drawEye(width / 2 + eyeSpacing / 2, centerY, eyeDiameter, lerpX, lerpY, isBlinking);

        // --- 4. 繪製右下角小鏡頭 ---
        drawCameraFeed();
      }

      function drawCameraFeed() {
        let camWidth = width * 0.2; // 縮小鏡頭顯示比例
        let camHeight = camWidth * (video.height / video.width);
        let camX = width - camWidth - 10;
        let camY = height - camHeight - 10;

        // 鏡頭外框
        fill(0, 80);
        rect(camX - 2, camY - 2, camWidth + 4, camHeight + 4);

        push();
        translate(camX + camWidth, camY);
        scale(-1, 1);
        // 這裡繪製 video，雖然 video 原始尺寸只有 160x120，但在這裡會被拉大顯示
        // 這不影響偵測速度，雖然畫面會有一點點馬賽克，但為了效能是值得的
        image(video, 0, 0, camWidth, camHeight);
        pop();
      }

      class Particle {
        constructor(x, y) {
          this.x = x + random(-5, 5);
          this.y = y + random(-5, 5);
          this.vx = random(-3, 3); // 速度快一點
          this.vy = random(-3, 3);
          this.alpha = 100;
          this.hue = random(0, 360); 
          this.size = random(5, 15);
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.alpha -= 8; // 消失速度加快 (原本是 4)
          this.size *= 0.9;
        }
        isFinished() { return this.alpha < 0; }
        show() {
          fill(this.hue, 80, 100, this.alpha);
          ellipse(this.x, this.y, this.size);
        }
      }

      function drawEye(eyeX, eyeY, eyeDiameter, targetX, targetY, blinking) {
        push();
        translate(eyeX, eyeY);

        if (blinking) {
            fill(240, 60, 20); 
            ellipse(0, 0, eyeDiameter, eyeDiameter);
            stroke(0, 0, 0, 50);
            strokeWeight(5);
            line(-eyeDiameter/2 * 0.7, 0, eyeDiameter/2 * 0.7, 0);
        } else {
            // 眼白
            noStroke();
            fill(0, 0, 95);
            ellipse(0, 0, eyeDiameter, eyeDiameter);

            // 眼珠計算
            let eyeRadius = eyeDiameter / 2;
            let pupilDiameter = eyeDiameter * 0.45;
            let maxOffset = (eyeRadius - pupilDiameter/2) * 0.9;

            let dx = targetX - eyeX;
            let dy = targetY - eyeY;
            let distToTarget = sqrt(dx*dx + dy*dy);

            let pupilOffsetX, pupilOffsetY;

            if (distToTarget < maxOffset) {
              pupilOffsetX = dx;
              pupilOffsetY = dy;
            } else {
              let angle = atan2(dy, dx);
              pupilOffsetX = cos(angle) * maxOffset;
              pupilOffsetY = sin(angle) * maxOffset;
            }

            // 眼珠
            translate(pupilOffsetX, pupilOffsetY);
            fill(0, 0, 10);
            ellipse(0, 0, pupilDiameter, pupilDiameter);
            // 反光
            fill(0, 0, 100, 90);
            ellipse(-pupilDiameter * 0.2, -pupilDiameter * 0.2, pupilDiameter * 0.25);
        }
        pop();
      }
    </script>
  </body>
</html>
