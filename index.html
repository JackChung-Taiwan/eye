<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Fast Eye Tracking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #111;
      }
      /* 確保畫布沒有卷軸 */
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      let handpose;
      let video;
      let predictions = [];
      
      // --- 核心流暢度設定 ---
      let lerpX = 0;
      let lerpY = 0;
      // 提高跟隨速度係數 (0.4 是一個反應快且不抖動的甜蜜點)
      let lerpSpeed = 0.4; 

      // 粒子系統 (限制數量以保證效能)
      let particles = [];
      const MAX_PARTICLES = 30; 

      // 自動眨眼
      let isBlinking = false;
      let nextBlinkTime = 0;
      let blinkEndTime = 0;
      let blinkDuration = 150;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 360, 100, 100, 100);
        angleMode(RADIANS);
        noStroke();

        lerpX = width / 2;
        lerpY = height / 2;
        nextBlinkTime = millis() + 2000;

        // --- 效能關鍵：極低解析度攝像頭 ---
        video = createCapture(VIDEO);
        // 設定 160x120 讓 AI 運算量最小化，速度最快
        video.size(160, 120); 
        video.hide(); // 隱藏 HTML 元素，且我們不在畫布上畫它

        console.log("啟動極速偵測模式...");
        
        // 載入模型
        handpose = ml5.handpose(video, () => {
          console.log("模型準備完成！");
        });
        
        // 監聽預測結果
        handpose.on("predict", (results) => {
          predictions = results;
        });
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }

      function draw() {
        // 使用不透明度較高的背景，減少瀏覽器繪圖負擔
        background(240, 80, 10, 40);

        let targetX, targetY;
        let handDetected = false;
        let currentTime = millis();

        // --- 1. 處理手部偵測數據 ---
        if (predictions.length > 0) {
          handDetected = true;
          isBlinking = false;
          nextBlinkTime = currentTime + random(2000, 4000);

          // 取得食指指尖
          let indexFinger = predictions[0].annotations.indexFinger[3];
          
          // 座標映射：從 160x120 映射到 全螢幕
          // X 軸 (width, 0) 反向映射，實現鏡像效果
          targetX = map(indexFinger[0], 0, video.width, width, 0);
          targetY = map(indexFinger[1], 0, video.height, 0, height);

          // 產生粒子 (少量)
          particles.push(new Particle(targetX, targetY));

        } else {
          // 無手勢：回到中心
          handDetected = false;
          targetX = width / 2;
          targetY = height / 2;

          // 自動眨眼邏輯
          if (!isBlinking && currentTime > nextBlinkTime) {
            isBlinking = true;
            blinkEndTime = currentTime + blinkDuration;
          } else if (isBlinking && currentTime > blinkEndTime) {
            isBlinking = false;
            nextBlinkTime = currentTime + random(2000, 5000);
          }
        }

        // --- 2. 粒子系統 (高效能版) ---
        // 強制刪除過多的粒子
        if (particles.length > MAX_PARTICLES) {
          particles.splice(0, particles.length - MAX_PARTICLES);
        }
        
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.update();
          p.show();
          if (p.isFinished()) {
            particles.splice(i, 1);
          }
        }

        // --- 3. 平滑移動運算 ---
        lerpX = lerp(lerpX, targetX, lerpSpeed);
        lerpY = lerp(lerpY, targetY, lerpSpeed);

        // --- 4. 繪製眼睛 ---
        let eyeDiameter = min(width, height) * 0.3;
        let eyeSpacing = eyeDiameter * 1.1;
        let centerY = height / 2;
        
        drawEye(width / 2 - eyeSpacing / 2, centerY, eyeDiameter, lerpX, lerpY, isBlinking);
        drawEye(width / 2 + eyeSpacing / 2, centerY, eyeDiameter, lerpX, lerpY, isBlinking);
        
        // 注意：這裡完全移除了 drawCameraPreview()，不會顯示鏡頭畫面
      }

      // --- 粒子類別 ---
      class Particle {
        constructor(x, y) {
          this.x = x + random(-8, 8);
          this.y = y + random(-8, 8);
          this.vx = random(-4, 4); // 速度快一點
          this.vy = random(-4, 4);
          this.alpha = 100;
          this.hue = random(0, 360);
          this.size = random(8, 20);
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.alpha -= 10; // 消失極快，避免畫面堆積
          this.size *= 0.9;
        }
        isFinished() { return this.alpha < 0; }
        show() {
          fill(this.hue, 80, 100, this.alpha);
          ellipse(this.x, this.y, this.size);
        }
      }

      // --- 眼球繪製函式 ---
      function drawEye(eyeX, eyeY, size, targetX, targetY, blink) {
        push();
        translate(eyeX, eyeY);

        if (blink) {
          // 眨眼樣式
          fill(240, 60, 20);
          ellipse(0, 0, size, size);
          stroke(0, 0, 0, 50);
          strokeWeight(6);
          line(-size * 0.35, 0, size * 0.35, 0);
        } else {
          // 1. 眼白
          noStroke();
          fill(0, 0, 95);
          ellipse(0, 0, size, size);

          // 2. 計算眼珠移動 (物理限制)
          let eyeRadius = size / 2;
          let pupilSize = size * 0.45;
          let pupilRadius = pupilSize / 2;
          let maxDist = (eyeRadius - pupilRadius) * 0.85; // 限制移動範圍

          let dx = targetX - eyeX;
          let dy = targetY - eyeY;
          let distToTarget = sqrt(dx*dx + dy*dy);
          
          let pupilX, pupilY;

          if (distToTarget < maxDist) {
            pupilX = dx;
            pupilY = dy;
          } else {
            let angle = atan2(dy, dx);
            pupilX = cos(angle) * maxDist;
            pupilY = sin(angle) * maxDist;
          }

          // 3. 眼珠
          translate(pupilX, pupilY);
          fill(0, 0, 10);
          ellipse(0, 0, pupilSize, pupilSize);
          
          // 4. 反光
          fill(0, 0, 100, 90);
          ellipse(-pupilSize * 0.2, -pupilSize * 0.2, pupilSize * 0.25);
        }
        pop();
      }
    </script>
  </body>
</html>
